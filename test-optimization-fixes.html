<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¼˜åŒ–æ¨¡å—Bugä¿®å¤éªŒè¯æµ‹è¯•</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .test-section {
            background: white;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-header {
            color: #333;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }
        .test-result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        }
        .test-pass {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .test-fail {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .test-info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .console-output {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 15px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }
        .stat-label {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <h1>ğŸ”§ ä¼˜åŒ–æ¨¡å—Bugä¿®å¤éªŒè¯æµ‹è¯•</h1>
    <p>æ­¤æµ‹è¯•é¡µé¢ç”¨äºéªŒè¯æ‰€æœ‰ä¼˜åŒ–æ¨¡å—çš„bugä¿®å¤æ•ˆæœï¼Œç¡®ä¿ç³»ç»Ÿç¨³å®šæ€§å’Œæ€§èƒ½ã€‚</p>

    <!-- è‡ªé€‚åº”å¹¶å‘æ§åˆ¶å™¨æµ‹è¯• -->
    <div class="test-section">
        <h2 class="test-header">1. è‡ªé€‚åº”å¹¶å‘æ§åˆ¶å™¨æµ‹è¯•</h2>
        <button onclick="testAdaptiveConcurrency()">æµ‹è¯•å¹¶å‘æ§åˆ¶å™¨</button>
        <div id="concurrency-results"></div>
        <div class="stats-grid" id="concurrency-stats"></div>
    </div>

    <!-- æ™ºèƒ½é‡è¯•ç®¡ç†å™¨æµ‹è¯• -->
    <div class="test-section">
        <h2 class="test-header">2. æ™ºèƒ½é‡è¯•ç®¡ç†å™¨æµ‹è¯•</h2>
        <button onclick="testSmartRetry()">æµ‹è¯•é‡è¯•ç®¡ç†å™¨</button>
        <div id="retry-results"></div>
        <div class="stats-grid" id="retry-stats"></div>
    </div>

    <!-- å¢å¼ºå†…å­˜ç®¡ç†å™¨æµ‹è¯• -->
    <div class="test-section">
        <h2 class="test-header">3. å¢å¼ºå†…å­˜ç®¡ç†å™¨æµ‹è¯•</h2>
        <button onclick="testMemoryManager()">æµ‹è¯•å†…å­˜ç®¡ç†å™¨</button>
        <div id="memory-results"></div>
        <div class="stats-grid" id="memory-stats"></div>
    </div>

    <!-- é«˜æ€§èƒ½å¤„ç†å™¨æµ‹è¯• -->
    <div class="test-section">
        <h2 class="test-header">4. é«˜æ€§èƒ½å¤„ç†å™¨æµ‹è¯•</h2>
        <button onclick="testHighPerformanceProcessor()">æµ‹è¯•æ‰¹å¤„ç†å™¨</button>
        <div id="processor-results"></div>
        <div class="stats-grid" id="processor-stats"></div>
    </div>

    <!-- ç½‘ç»œä¼˜åŒ–å™¨æµ‹è¯• -->
    <div class="test-section">
        <h2 class="test-header">5. ç½‘ç»œä¼˜åŒ–å™¨æµ‹è¯•</h2>
        <button onclick="testNetworkOptimizer()">æµ‹è¯•ç½‘ç»œä¼˜åŒ–å™¨</button>
        <div id="network-results"></div>
        <div class="stats-grid" id="network-stats"></div>
    </div>

    <!-- é«˜é€Ÿæ§åˆ¶å™¨é›†æˆæµ‹è¯• -->
    <div class="test-section">
        <h2 class="test-header">6. é«˜é€Ÿæ§åˆ¶å™¨é›†æˆæµ‹è¯•</h2>
        <button onclick="testHighSpeedController()">æµ‹è¯•é›†æˆæ§åˆ¶å™¨</button>
        <div id="controller-results"></div>
        <div class="stats-grid" id="controller-stats"></div>
    </div>

    <!-- ç»¼åˆå‹åŠ›æµ‹è¯• -->
    <div class="test-section">
        <h2 class="test-header">7. ç»¼åˆå‹åŠ›æµ‹è¯•</h2>
        <button onclick="runStressTest()">è¿è¡Œå‹åŠ›æµ‹è¯•</button>
        <button onclick="runMemoryLeakTest()">å†…å­˜æ³„æ¼æµ‹è¯•</button>
        <div id="stress-results"></div>
        <div class="console-output" id="console-log"></div>
    </div>

    <!-- åŠ è½½ä¼˜åŒ–æ¨¡å— -->
    <script src="js/core/adaptiveConcurrencyManager.js"></script>
    <script src="js/core/smartRetryManager.js"></script>
    <script src="js/core/enhancedMemoryManager.js"></script>
    <script src="js/core/highPerformanceProcessor.js"></script>
    <script src="js/core/networkOptimizer.js"></script>
    <script src="js/core/highSpeedController.js"></script>

    <script>
        // æµ‹è¯•ç»“æœè®°å½•
        let testResults = {
            passed: 0,
            failed: 0,
            total: 0
        };

        // æ§åˆ¶å°æ—¥å¿—æ•è·
        const originalConsoleLog = console.log;
        const originalConsoleError = console.error;
        const originalConsoleWarn = console.warn;
        
        function captureConsoleOutput() {
            const consoleOutput = document.getElementById('console-log');
            
            console.log = function(...args) {
                originalConsoleLog.apply(console, args);
                consoleOutput.textContent += '[LOG] ' + args.join(' ') + '\n';
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            };
            
            console.error = function(...args) {
                originalConsoleError.apply(console, args);
                consoleOutput.textContent += '[ERROR] ' + args.join(' ') + '\n';
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            };
            
            console.warn = function(...args) {
                originalConsoleWarn.apply(console, args);
                consoleOutput.textContent += '[WARN] ' + args.join(' ') + '\n';
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            };
        }

        // æµ‹è¯•è¾…åŠ©å‡½æ•°
        function addTestResult(containerId, testName, passed, message, details = null) {
            const container = document.getElementById(containerId);
            const resultDiv = document.createElement('div');
            resultDiv.className = `test-result ${passed ? 'test-pass' : 'test-fail'}`;
            
            let content = `<strong>${testName}</strong>: ${message}`;
            if (details) {
                content += `<br><small>${details}</small>`;
            }
            resultDiv.innerHTML = content;
            
            container.appendChild(resultDiv);
            
            testResults.total++;
            if (passed) testResults.passed++;
            else testResults.failed++;
        }

        function addStats(containerId, stats) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            Object.entries(stats).forEach(([key, value]) => {
                const statCard = document.createElement('div');
                statCard.className = 'stat-card';
                statCard.innerHTML = `
                    <div class="stat-value">${value}</div>
                    <div class="stat-label">${key}</div>
                `;
                container.appendChild(statCard);
            });
        }

        // 1. è‡ªé€‚åº”å¹¶å‘æ§åˆ¶å™¨æµ‹è¯•
        async function testAdaptiveConcurrency() {
            const resultsContainer = document.getElementById('concurrency-results');
            resultsContainer.innerHTML = '';
            
            try {
                // æµ‹è¯•åŸºæœ¬åŠŸèƒ½
                if (typeof adaptiveConcurrencyManager === 'undefined') {
                    addTestResult('concurrency-results', 'æ¨¡å—åŠ è½½', false, 'è‡ªé€‚åº”å¹¶å‘æ§åˆ¶å™¨æœªåŠ è½½');
                    return;
                }
                
                addTestResult('concurrency-results', 'æ¨¡å—åŠ è½½', true, 'è‡ªé€‚åº”å¹¶å‘æ§åˆ¶å™¨å·²åŠ è½½');
                
                // æµ‹è¯•æ§½ä½è·å–å’Œé‡Šæ”¾
                const slot = await adaptiveConcurrencyManager.acquireSlot();
                addTestResult('concurrency-results', 'æ§½ä½è·å–', !!slot, slot ? `æ§½ä½ID: ${slot.id}` : 'è·å–å¤±è´¥');
                
                if (slot) {
                    adaptiveConcurrencyManager.releaseSlot(slot, { success: true });
                    addTestResult('concurrency-results', 'æ§½ä½é‡Šæ”¾', true, 'æˆåŠŸé‡Šæ”¾æ§½ä½');
                }
                
                // æµ‹è¯•ç»Ÿè®¡åŠŸèƒ½
                const stats = adaptiveConcurrencyManager.getDetailedStats();
                addTestResult('concurrency-results', 'ç»Ÿè®¡è·å–', !!stats, 'ç»Ÿè®¡æ•°æ®è·å–æˆåŠŸ');
                
                addStats('concurrency-stats', {
                    'å½“å‰å¹¶å‘': stats.concurrency?.current || 0,
                    'æœ€å¤§å¹¶å‘': stats.concurrency?.max || 0,
                    'æ€»è¯·æ±‚æ•°': stats.performance?.totalRequests || 0,
                    'æˆåŠŸç‡': ((stats.performance?.successRate || 0) * 100).toFixed(1) + '%'
                });
                
            } catch (error) {
                addTestResult('concurrency-results', 'å¼‚å¸¸å¤„ç†', false, `æµ‹è¯•å‡ºé”™: ${error.message}`);
            }
        }

        // 2. æ™ºèƒ½é‡è¯•ç®¡ç†å™¨æµ‹è¯•
        async function testSmartRetry() {
            const resultsContainer = document.getElementById('retry-results');
            resultsContainer.innerHTML = '';
            
            try {
                if (typeof smartRetryManager === 'undefined') {
                    addTestResult('retry-results', 'æ¨¡å—åŠ è½½', false, 'æ™ºèƒ½é‡è¯•ç®¡ç†å™¨æœªåŠ è½½');
                    return;
                }
                
                addTestResult('retry-results', 'æ¨¡å—åŠ è½½', true, 'æ™ºèƒ½é‡è¯•ç®¡ç†å™¨å·²åŠ è½½');
                
                // æµ‹è¯•æˆåŠŸåœºæ™¯
                let successCount = 0;
                const successTest = async () => {
                    successCount++;
                    if (successCount === 1) throw new Error('First attempt fails');
                    return { success: true };
                };
                
                const result = await smartRetryManager.executeWithRetry('test-key', successTest, { apiType: 'test' });
                addTestResult('retry-results', 'é‡è¯•æˆåŠŸ', result.success, 'ç¬¬äºŒæ¬¡å°è¯•æˆåŠŸ');
                
                // æµ‹è¯•å¿«é€Ÿå¤±è´¥
                const fastFailTest = async () => {
                    const error = new Error('401 Unauthorized');
                    error.status = 401;
                    throw error;
                };
                
                try {
                    await smartRetryManager.executeWithRetry('test-key-2', fastFailTest, { apiType: 'test' });
                    addTestResult('retry-results', 'å¿«é€Ÿå¤±è´¥', false, 'åº”è¯¥å¿«é€Ÿå¤±è´¥ä½†æ²¡æœ‰');
                } catch (error) {
                    addTestResult('retry-results', 'å¿«é€Ÿå¤±è´¥', true, '401é”™è¯¯å¿«é€Ÿå¤±è´¥');
                }
                
                const stats = smartRetryManager.getStats();
                addStats('retry-stats', {
                    'æ€»é‡è¯•': stats.totalRetries || 0,
                    'æˆåŠŸé‡è¯•': stats.successfulRetries || 0,
                    'å¿«é€Ÿå¤±è´¥': stats.fastFails || 0,
                    'ç†”æ–­è§¦å‘': stats.circuitBreakerTrips || 0
                });
                
            } catch (error) {
                addTestResult('retry-results', 'å¼‚å¸¸å¤„ç†', false, `æµ‹è¯•å‡ºé”™: ${error.message}`);
            }
        }

        // 3. å¢å¼ºå†…å­˜ç®¡ç†å™¨æµ‹è¯•
        async function testMemoryManager() {
            const resultsContainer = document.getElementById('memory-results');
            resultsContainer.innerHTML = '';
            
            try {
                if (typeof enhancedMemoryManager === 'undefined') {
                    addTestResult('memory-results', 'æ¨¡å—åŠ è½½', false, 'å¢å¼ºå†…å­˜ç®¡ç†å™¨æœªåŠ è½½');
                    return;
                }
                
                addTestResult('memory-results', 'æ¨¡å—åŠ è½½', true, 'å¢å¼ºå†…å­˜ç®¡ç†å™¨å·²åŠ è½½');
                
                // æµ‹è¯•æ·»åŠ å¯†é’¥
                for (let i = 0; i < 100; i++) {
                    enhancedMemoryManager.addKey({
                        key: `test-key-${i}`,
                        status: 'pending',
                        startTime: Date.now()
                    });
                }
                addTestResult('memory-results', 'æ‰¹é‡æ·»åŠ ', true, 'æˆåŠŸæ·»åŠ 100ä¸ªæµ‹è¯•å¯†é’¥');
                
                // æµ‹è¯•çŠ¶æ€æ›´æ–°
                enhancedMemoryManager.updateKeyStatus('test-key-0', 'valid', { model: 'test-model' });
                addTestResult('memory-results', 'çŠ¶æ€æ›´æ–°', true, 'æˆåŠŸæ›´æ–°å¯†é’¥çŠ¶æ€');
                
                // æµ‹è¯•æ‰¹é‡è·å–
                const keys = enhancedMemoryManager.getKeysBatch({}, 10);
                addTestResult('memory-results', 'æ‰¹é‡è·å–', keys.length > 0, `è·å–åˆ°${keys.length}ä¸ªå¯†é’¥`);
                
                // æµ‹è¯•æ¸…ç†åŠŸèƒ½
                enhancedMemoryManager.performCleanup();
                addTestResult('memory-results', 'å†…å­˜æ¸…ç†', true, 'å†…å­˜æ¸…ç†æ‰§è¡Œå®Œæˆ');
                
                const stats = enhancedMemoryManager.getDetailedStats();
                addStats('memory-stats', {
                    'æ€»å¯†é’¥': stats.memory?.totalKeys || 0,
                    'æ´»è·ƒå¯†é’¥': stats.memory?.activeKeys || 0,
                    'å†…å­˜ä½¿ç”¨': stats.memory?.estimatedUsage || '0 MB',
                    'æ¸…ç†æ¬¡æ•°': stats.performance?.cleanupCount || 0
                });
                
            } catch (error) {
                addTestResult('memory-results', 'å¼‚å¸¸å¤„ç†', false, `æµ‹è¯•å‡ºé”™: ${error.message}`);
            }
        }

        // 4. é«˜æ€§èƒ½å¤„ç†å™¨æµ‹è¯•
        async function testHighPerformanceProcessor() {
            const resultsContainer = document.getElementById('processor-results');
            resultsContainer.innerHTML = '';
            
            try {
                if (typeof highPerformanceProcessor === 'undefined') {
                    addTestResult('processor-results', 'æ¨¡å—åŠ è½½', false, 'é«˜æ€§èƒ½å¤„ç†å™¨æœªåŠ è½½');
                    return;
                }
                
                addTestResult('processor-results', 'æ¨¡å—åŠ è½½', true, 'é«˜æ€§èƒ½å¤„ç†å™¨å·²åŠ è½½');
                
                // æµ‹è¯•æ‰¹å¤„ç†
                const testData = Array.from({length: 50}, (_, i) => ({ id: i, value: `test-${i}` }));
                const processor = async (item, index) => {
                    await new Promise(resolve => setTimeout(resolve, 10)); // æ¨¡æ‹Ÿå¼‚æ­¥å¤„ç†
                    return { processed: true, item, index };
                };
                
                const startTime = Date.now();
                const result = await highPerformanceProcessor.processBatch(testData, processor, { batchSize: 10 });
                const processingTime = Date.now() - startTime;
                
                addTestResult('processor-results', 'æ‰¹å¤„ç†', result.totalProcessed > 0, 
                    `å¤„ç†${result.totalProcessed}ä¸ªé¡¹ç›®ï¼Œè€—æ—¶${processingTime}ms`);
                
                // æµ‹è¯•UIæ›´æ–°
                highPerformanceProcessor.cacheResults([
                    { success: true, result: { status: 'valid', key: 'test-key' } }
                ]);
                addTestResult('processor-results', 'ç»“æœç¼“å­˜', true, 'æˆåŠŸç¼“å­˜å¤„ç†ç»“æœ');
                
                const stats = highPerformanceProcessor.getMetrics();
                addStats('processor-stats', {
                    'å¤„ç†æ‰¹æ¬¡': stats.processedBatches || 0,
                    'å¹³å‡æ‰¹æ¬¡æ—¶é—´': stats.avgBatchTime || '0ms',
                    'UIæ›´æ–°æ¬¡æ•°': stats.uiUpdateCount || 0,
                    'ä¸¢å¸§æ•°': stats.droppedFrames || 0
                });
                
            } catch (error) {
                addTestResult('processor-results', 'å¼‚å¸¸å¤„ç†', false, `æµ‹è¯•å‡ºé”™: ${error.message}`);
            }
        }

        // 5. ç½‘ç»œä¼˜åŒ–å™¨æµ‹è¯•
        async function testNetworkOptimizer() {
            const resultsContainer = document.getElementById('network-results');
            resultsContainer.innerHTML = '';
            
            try {
                if (typeof networkOptimizer === 'undefined') {
                    addTestResult('network-results', 'æ¨¡å—åŠ è½½', false, 'ç½‘ç»œä¼˜åŒ–å™¨æœªåŠ è½½');
                    return;
                }
                
                addTestResult('network-results', 'æ¨¡å—åŠ è½½', true, 'ç½‘ç»œä¼˜åŒ–å™¨å·²åŠ è½½');
                
                // æµ‹è¯•è¿æ¥æ± 
                const host = 'test.example.com';
                const connection = networkOptimizer.createConnection(host);
                addTestResult('network-results', 'è¿æ¥åˆ›å»º', !!connection, `è¿æ¥ID: ${connection?.id}`);
                
                if (connection) {
                    networkOptimizer.releaseConnection(host, connection);
                    addTestResult('network-results', 'è¿æ¥é‡Šæ”¾', true, 'è¿æ¥æˆåŠŸé‡Šæ”¾åˆ°æ± ä¸­');
                }
                
                // æµ‹è¯•æ¸…ç†åŠŸèƒ½
                networkOptimizer.cleanupExpiredConnections();
                addTestResult('network-results', 'è¿æ¥æ¸…ç†', true, 'è¿‡æœŸè¿æ¥æ¸…ç†å®Œæˆ');
                
                const stats = networkOptimizer.getDetailedStats();
                addStats('network-stats', {
                    'æ€»è¯·æ±‚': stats.requests?.total || 0,
                    'åˆå¹¶è¯·æ±‚': stats.requests?.merged || 0,
                    'è¿æ¥æ± å‘½ä¸­': stats.connections?.poolHits || 0,
                    'ç½‘ç»œé”™è¯¯': stats.performance?.networkErrors || 0
                });
                
            } catch (error) {
                addTestResult('network-results', 'å¼‚å¸¸å¤„ç†', false, `æµ‹è¯•å‡ºé”™: ${error.message}`);
            }
        }

        // 6. é«˜é€Ÿæ§åˆ¶å™¨é›†æˆæµ‹è¯•
        async function testHighSpeedController() {
            const resultsContainer = document.getElementById('controller-results');
            resultsContainer.innerHTML = '';
            
            try {
                if (typeof highSpeedController === 'undefined') {
                    addTestResult('controller-results', 'æ¨¡å—åŠ è½½', false, 'é«˜é€Ÿæ§åˆ¶å™¨æœªåŠ è½½');
                    return;
                }
                
                addTestResult('controller-results', 'æ¨¡å—åŠ è½½', true, 'é«˜é€Ÿæ§åˆ¶å™¨å·²åŠ è½½');
                
                // æµ‹è¯•åˆå§‹åŒ–
                await highSpeedController.initialize();
                addTestResult('controller-results', 'åˆå§‹åŒ–', highSpeedController.isInitialized, 'æ§åˆ¶å™¨åˆå§‹åŒ–å®Œæˆ');
                
                // æµ‹è¯•æ¨¡å—é›†æˆ
                const stats = highSpeedController.getDetailedStats();
                const moduleCount = Object.keys(stats.modules || {}).length;
                addTestResult('controller-results', 'æ¨¡å—é›†æˆ', moduleCount > 0, `é›†æˆäº†${moduleCount}ä¸ªä¼˜åŒ–æ¨¡å—`);
                
                // æµ‹è¯•é…ç½®æ›´æ–°
                highSpeedController.config.maxConcurrency = 20;
                addTestResult('controller-results', 'é…ç½®æ›´æ–°', true, 'æˆåŠŸæ›´æ–°é…ç½®å‚æ•°');
                
                // æµ‹è¯•æ¸…ç†åŠŸèƒ½
                const originalCleanup = highSpeedController.cleanup;
                let cleanupCalled = false;
                highSpeedController.cleanup = function() {
                    cleanupCalled = true;
                    return originalCleanup.call(this);
                };
                
                addStats('controller-stats', {
                    'åˆå§‹åŒ–çŠ¶æ€': highSpeedController.isInitialized ? 'æ˜¯' : 'å¦',
                    'è¿è¡ŒçŠ¶æ€': highSpeedController.isRunning ? 'æ˜¯' : 'å¦',
                    'é›†æˆæ¨¡å—': moduleCount,
                    'æœ€å¤§å¹¶å‘': highSpeedController.config.maxConcurrency
                });
                
            } catch (error) {
                addTestResult('controller-results', 'å¼‚å¸¸å¤„ç†', false, `æµ‹è¯•å‡ºé”™: ${error.message}`);
            }
        }

        // 7. ç»¼åˆå‹åŠ›æµ‹è¯•
        async function runStressTest() {
            const resultsContainer = document.getElementById('stress-results');
            resultsContainer.innerHTML = '<div class="test-info">æ­£åœ¨è¿è¡Œå‹åŠ›æµ‹è¯•...</div>';
            
            try {
                const startTime = Date.now();
                const promises = [];
                
                // å¹¶å‘æµ‹è¯•è‡ªé€‚åº”å¹¶å‘æ§åˆ¶å™¨
                for (let i = 0; i < 100; i++) {
                    promises.push((async () => {
                        const slot = await adaptiveConcurrencyManager.acquireSlot();
                        await new Promise(resolve => setTimeout(resolve, Math.random() * 100));
                        adaptiveConcurrencyManager.releaseSlot(slot, { success: Math.random() > 0.1 });
                    })());
                }
                
                await Promise.all(promises);
                const totalTime = Date.now() - startTime;
                
                addTestResult('stress-results', 'å¹¶å‘å‹åŠ›æµ‹è¯•', true, 
                    `100ä¸ªå¹¶å‘è¯·æ±‚å®Œæˆï¼Œæ€»è€—æ—¶: ${totalTime}ms`);
                
                // å†…å­˜å‹åŠ›æµ‹è¯•
                const memoryBefore = performance.memory ? performance.memory.usedJSHeapSize : 0;
                
                for (let i = 0; i < 1000; i++) {
                    enhancedMemoryManager.addKey({
                        key: `stress-test-${i}`,
                        status: 'pending',
                        data: new Array(100).fill('test-data')
                    });
                }
                
                const memoryAfter = performance.memory ? performance.memory.usedJSHeapSize : 0;
                const memoryIncrease = memoryAfter - memoryBefore;
                
                addTestResult('stress-results', 'å†…å­˜å‹åŠ›æµ‹è¯•', true, 
                    `æ·»åŠ 1000ä¸ªå¯†é’¥ï¼Œå†…å­˜å¢åŠ : ${(memoryIncrease / 1024 / 1024).toFixed(2)}MB`);
                
            } catch (error) {
                addTestResult('stress-results', 'å‹åŠ›æµ‹è¯•', false, `æµ‹è¯•å¤±è´¥: ${error.message}`);
            }
        }

        // å†…å­˜æ³„æ¼æµ‹è¯•
        async function runMemoryLeakTest() {
            const resultsContainer = document.getElementById('stress-results');
            
            if (!performance.memory) {
                addTestResult('stress-results', 'å†…å­˜æ³„æ¼æµ‹è¯•', false, 'æµè§ˆå™¨ä¸æ”¯æŒå†…å­˜ç›‘æ§');
                return;
            }
            
            const initialMemory = performance.memory.usedJSHeapSize;
            
            // åˆ›å»ºå’Œé”€æ¯å¤§é‡å¯¹è±¡
            for (let cycle = 0; cycle < 5; cycle++) {
                // åˆ›å»ºå¯¹è±¡
                const objects = [];
                for (let i = 0; i < 1000; i++) {
                    objects.push({
                        id: i,
                        data: new Array(1000).fill(`cycle-${cycle}-item-${i}`),
                        timestamp: Date.now()
                    });
                }
                
                // æ¨¡æ‹Ÿå¤„ç†
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // æ¸…ç†
                objects.length = 0;
                
                // å¼ºåˆ¶åƒåœ¾å›æ”¶ï¼ˆå¦‚æœå¯ç”¨ï¼‰
                if (window.gc) {
                    window.gc();
                }
                
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            const finalMemory = performance.memory.usedJSHeapSize;
            const memoryDiff = finalMemory - initialMemory;
            const memoryDiffMB = memoryDiff / 1024 / 1024;
            
            const hasLeak = memoryDiffMB > 10; // è¶…è¿‡10MBè®¤ä¸ºå¯èƒ½æœ‰æ³„æ¼
            
            addTestResult('stress-results', 'å†…å­˜æ³„æ¼æµ‹è¯•', !hasLeak, 
                `å†…å­˜å˜åŒ–: ${memoryDiffMB.toFixed(2)}MB ${hasLeak ? '(å¯èƒ½å­˜åœ¨æ³„æ¼)' : '(æ­£å¸¸)'}`);
        }

        // é¡µé¢åŠ è½½å®Œæˆåå¯åŠ¨
        document.addEventListener('DOMContentLoaded', function() {
            captureConsoleOutput();
            console.log('ä¼˜åŒ–æ¨¡å—Bugä¿®å¤éªŒè¯æµ‹è¯•é¡µé¢å·²åŠ è½½');
            
            // æ˜¾ç¤ºæµ‹è¯•æ¦‚è¿°
            const overview = document.createElement('div');
            overview.className = 'test-section';
            overview.innerHTML = `
                <h2 class="test-header">æµ‹è¯•æ¦‚è¿°</h2>
                <div class="test-info">
                    <strong>æµ‹è¯•ç›®æ ‡:</strong> éªŒè¯æ‰€æœ‰ä¼˜åŒ–æ¨¡å—çš„bugä¿®å¤æ•ˆæœ<br>
                    <strong>æµ‹è¯•èŒƒå›´:</strong> 6ä¸ªæ ¸å¿ƒä¼˜åŒ–æ¨¡å— + ç»¼åˆå‹åŠ›æµ‹è¯•<br>
                    <strong>ä¿®å¤å†…å®¹:</strong> å†…å­˜æ³„æ¼ã€é”™è¯¯å¤„ç†ã€èµ„æºæ¸…ç†ã€å…¼å®¹æ€§é—®é¢˜<br>
                    <strong>çŠ¶æ€:</strong> å‡†å¤‡å°±ç»ªï¼Œç‚¹å‡»å„æ¨¡å—æµ‹è¯•æŒ‰é’®å¼€å§‹éªŒè¯
                </div>
            `;
            document.body.insertBefore(overview, document.body.firstChild.nextSibling);
        });
    </script>
</body>
</html>
