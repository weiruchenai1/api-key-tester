<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å†…å­˜æ³„æ¼æ£€æµ‹å·¥å…· - APIå¯†é’¥æµ‹è¯•å™¨</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
        }
        
        .content {
            padding: 30px;
        }
        
        .control-panel {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
            color: white;
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
            color: white;
        }
        
        .btn-warning {
            background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);
            color: white;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.2);
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 20px;
            border-radius: 12px;
            border-left: 5px solid #4CAF50;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .stat-card.warning {
            border-left-color: #FF9800;
        }
        
        .stat-card.danger {
            border-left-color: #f44336;
        }
        
        .stat-title {
            font-size: 14px;
            color: #666;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }
        
        .chart-container {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .chart-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
        }
        
        .chart {
            width: 100%;
            height: 300px;
            border: 1px solid #ddd;
            border-radius: 8px;
            position: relative;
            background: #fafafa;
        }
        
        .log-container {
            background: #1e1e1e;
            color: #fff;
            border-radius: 12px;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .log-entry {
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 4px;
        }
        
        .log-info {
            background: rgba(33, 150, 243, 0.2);
            border-left: 3px solid #2196F3;
        }
        
        .log-warning {
            background: rgba(255, 152, 0, 0.2);
            border-left: 3px solid #FF9800;
        }
        
        .log-error {
            background: rgba(244, 67, 54, 0.2);
            border-left: 3px solid #f44336;
        }
        
        .log-success {
            background: rgba(76, 175, 80, 0.2);
            border-left: 3px solid #4CAF50;
        }
        
        .recommendations {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            border: 1px solid #ffc107;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .recommendations h3 {
            margin-top: 0;
            color: #856404;
        }
        
        .recommendation {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #ffc107;
        }
        
        .recommendation.critical {
            border-left-color: #dc3545;
            background: #fff5f5;
        }
        
        .recommendation.warning {
            border-left-color: #fd7e14;
            background: #fff8f0;
        }
        
        .recommendation-title {
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .recommendation-actions {
            margin-top: 10px;
        }
        
        .recommendation-actions ul {
            margin: 5px 0;
            padding-left: 20px;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-monitoring {
            background: #4CAF50;
            animation: pulse 2s infinite;
        }
        
        .status-stopped {
            background: #ccc;
        }
        
        .status-warning {
            background: #FF9800;
            animation: pulse 2s infinite;
        }
        
        .status-error {
            background: #f44336;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50 0%, #45a049 100%);
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ” å†…å­˜æ³„æ¼æ£€æµ‹å·¥å…·</h1>
            <p>å®æ—¶ç›‘æ§APIå¯†é’¥æµ‹è¯•å™¨çš„å†…å­˜ä½¿ç”¨æƒ…å†µï¼Œæ£€æµ‹æ½œåœ¨çš„å†…å­˜æ³„æ¼é—®é¢˜</p>
        </div>
        
        <div class="content">
            <!-- æ§åˆ¶é¢æ¿ -->
            <div class="control-panel">
                <button id="startBtn" class="btn btn-primary">
                    <span class="status-indicator status-stopped"></span>
                    å¼€å§‹ç›‘æ§
                </button>
                <button id="stopBtn" class="btn btn-secondary" disabled>
                    åœæ­¢ç›‘æ§
                </button>
                <button id="clearBtn" class="btn btn-warning">
                    æ¸…é™¤æ•°æ®
                </button>
                <button id="reportBtn" class="btn btn-secondary">
                    ç”ŸæˆæŠ¥å‘Š
                </button>
                <button id="testLeakBtn" class="btn btn-danger">
                    æ¨¡æ‹Ÿå†…å­˜æ³„æ¼
                </button>
            </div>
            
            <!-- å®æ—¶ç»Ÿè®¡ -->
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-title">å½“å‰å†…å­˜ä½¿ç”¨</div>
                    <div class="stat-value" id="currentMemory">0 MB</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">å†…å­˜å¢é•¿</div>
                    <div class="stat-value" id="memoryGrowth">0 MB</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">ç›‘æ§æ—¶é•¿</div>
                    <div class="stat-value" id="monitoringDuration">0 ç§’</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">æ³„æ¼é£é™©</div>
                    <div class="stat-value" id="leakRisk">ä½</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">DOMèŠ‚ç‚¹æ•°</div>
                    <div class="stat-value" id="domNodes">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">æ ·æœ¬æ•°é‡</div>
                    <div class="stat-value" id="sampleCount">0</div>
                </div>
            </div>
            
            <!-- å†…å­˜ä½¿ç”¨å›¾è¡¨ -->
            <div class="chart-container">
                <div class="chart-title">ğŸ“Š å†…å­˜ä½¿ç”¨è¶‹åŠ¿</div>
                <canvas id="memoryChart" class="chart"></canvas>
            </div>
            
            <!-- å»ºè®®å’Œè­¦å‘Š -->
            <div id="recommendationsContainer" class="recommendations" style="display: none;">
                <h3>ğŸš¨ æ£€æµ‹ç»“æœå’Œå»ºè®®</h3>
                <div id="recommendationsList"></div>
            </div>
            
            <!-- å®æ—¶æ—¥å¿— -->
            <div class="chart-container">
                <div class="chart-title">ğŸ“ å®æ—¶ç›‘æ§æ—¥å¿—</div>
                <div id="logContainer" class="log-container">
                    <div class="log-entry log-info">
                        [INFO] å†…å­˜æ³„æ¼æ£€æµ‹å·¥å…·å·²åŠ è½½ï¼Œç‚¹å‡»"å¼€å§‹ç›‘æ§"å¼€å§‹æ£€æµ‹
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ç›´æ¥åœ¨HTMLä¸­å®šä¹‰MemoryLeakDetectorç±»
        class MemoryLeakDetector {
            constructor() {
                this.config = {
                    samplingInterval: 1000,        // é‡‡æ ·é—´éš”1ç§’
                    maxSamples: 300,              // æœ€å¤šä¿å­˜300ä¸ªæ ·æœ¬(5åˆ†é’Ÿ)
                    leakThreshold: 0.1,           // æ³„æ¼é˜ˆå€¼10%
                    growthThreshold: 50 * 1024 * 1024, // å¢é•¿é˜ˆå€¼50MB
                    stabilityWindow: 30,          // ç¨³å®šæ€§çª—å£30ç§’
                    alertThreshold: 100 * 1024 * 1024 // è­¦å‘Šé˜ˆå€¼100MB
                };
                
                this.samples = [];
                this.isMonitoring = false;
                this.monitoringTimer = null;
                this.listeners = [];
                this.baseline = null;
                
                console.log('[MemoryLeakDetector] å†…å­˜æ³„æ¼æ£€æµ‹å™¨å·²åˆå§‹åŒ–');
            }
            
            startMonitoring() {
                if (this.isMonitoring) {
                    console.warn('[MemoryLeakDetector] å·²åœ¨ç›‘æ§ä¸­');
                    return;
                }
                
                this.isMonitoring = true;
                this.samples = [];
                this.baseline = this.getCurrentMemoryUsage();
                
                this.monitoringTimer = setInterval(() => {
                    this.collectSample();
                }, this.config.samplingInterval);
                
                console.log('[MemoryLeakDetector] å¼€å§‹å†…å­˜ç›‘æ§');
                this.notifyListeners('monitoring_started', { baseline: this.baseline });
            }
            
            stopMonitoring() {
                if (!this.isMonitoring) {
                    return;
                }
                
                this.isMonitoring = false;
                
                if (this.monitoringTimer) {
                    clearInterval(this.monitoringTimer);
                    this.monitoringTimer = null;
                }
                
                const analysis = this.analyzeMemoryUsage();
                
                console.log('[MemoryLeakDetector] åœæ­¢å†…å­˜ç›‘æ§');
                this.notifyListeners('monitoring_stopped', analysis);
                
                return analysis;
            }
            
            collectSample() {
                const sample = {
                    timestamp: Date.now(),
                    memory: this.getCurrentMemoryUsage(),
                    domNodes: this.getDOMNodeCount()
                };
                
                this.samples.push(sample);
                
                if (this.samples.length > this.config.maxSamples) {
                    this.samples.shift();
                }
                
                this.checkForAnomalies(sample);
                this.notifyListeners('sample_collected', sample);
            }
            
            getCurrentMemoryUsage() {
                const memInfo = {
                    used: 0,
                    total: 0,
                    limit: 0,
                    available: 0
                };
                
                if (typeof performance !== 'undefined' && performance.memory) {
                    memInfo.used = performance.memory.usedJSHeapSize;
                    memInfo.total = performance.memory.totalJSHeapSize;
                    memInfo.limit = performance.memory.jsHeapSizeLimit;
                    memInfo.available = memInfo.limit - memInfo.used;
                }
                
                return memInfo;
            }
            
            getDOMNodeCount() {
                if (typeof document !== 'undefined') {
                    return document.getElementsByTagName('*').length;
                }
                return 0;
            }
            
            checkForAnomalies(sample) {
                if (this.samples.length < 10) return;
                
                const recentSamples = this.samples.slice(-10);
                const memoryGrowth = sample.memory.used - recentSamples[0].memory.used;
                
                if (memoryGrowth > this.config.growthThreshold) {
                    this.notifyListeners('anomaly_detected', {
                        type: 'rapid_growth',
                        growth: memoryGrowth,
                        sample: sample
                    });
                }
                
                if (sample.memory.used > this.config.alertThreshold) {
                    this.notifyListeners('anomaly_detected', {
                        type: 'high_usage',
                        usage: sample.memory.used,
                        sample: sample
                    });
                }
            }
            
            analyzeMemoryUsage() {
                if (this.samples.length < 2) {
                    return {
                        hasLeak: false,
                        message: 'æ ·æœ¬æ•°æ®ä¸è¶³ï¼Œæ— æ³•åˆ†æ',
                        recommendations: []
                    };
                }
                
                const analysis = {
                    duration: this.samples[this.samples.length - 1].timestamp - this.samples[0].timestamp,
                    totalSamples: this.samples.length,
                    memoryStats: this.calculateMemoryStats(),
                    leakDetection: this.detectMemoryLeak(),
                    recommendations: []
                };
                
                analysis.recommendations = this.generateRecommendations(analysis);
                return analysis;
            }
            
            calculateMemoryStats() {
                const memoryValues = this.samples.map(s => s.memory.used);
                const domCounts = this.samples.map(s => s.domNodes);
                
                return {
                    memory: {
                        min: Math.min(...memoryValues),
                        max: Math.max(...memoryValues),
                        avg: memoryValues.reduce((a, b) => a + b, 0) / memoryValues.length,
                        growth: memoryValues[memoryValues.length - 1] - memoryValues[0],
                        trend: this.calculateTrend(memoryValues)
                    },
                    domNodes: {
                        min: Math.min(...domCounts),
                        max: Math.max(...domCounts),
                        avg: domCounts.reduce((a, b) => a + b, 0) / domCounts.length,
                        growth: domCounts[domCounts.length - 1] - domCounts[0]
                    }
                };
            }
            
            detectMemoryLeak() {
                const memoryValues = this.samples.map(s => s.memory.used);
                const trend = this.calculateTrend(memoryValues);
                const growth = memoryValues[memoryValues.length - 1] - memoryValues[0];
                const duration = this.samples[this.samples.length - 1].timestamp - this.samples[0].timestamp;
                
                const leakRate = (growth / (1024 * 1024)) / (duration / 60000);
                const hasLeak = trend > this.config.leakThreshold && leakRate > 1;
                
                return {
                    hasLeak,
                    leakRate,
                    trend,
                    growth,
                    confidence: this.calculateLeakConfidence(trend, leakRate, memoryValues)
                };
            }
            
            calculateTrend(values) {
                if (values.length < 2) return 0;
                
                const n = values.length;
                const sumX = (n * (n - 1)) / 2;
                const sumY = values.reduce((a, b) => a + b, 0);
                const sumXY = values.reduce((sum, y, x) => sum + x * y, 0);
                const sumX2 = values.reduce((sum, _, x) => sum + x * x, 0);
                
                const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                return slope;
            }
            
            calculateLeakConfidence(trend, leakRate, values) {
                let confidence = 0;
                
                if (trend > 0.5) confidence += 0.4;
                else if (trend > 0.2) confidence += 0.2;
                
                if (leakRate > 5) confidence += 0.4;
                else if (leakRate > 2) confidence += 0.2;
                
                const stability = this.calculateStability(values);
                if (stability < 0.1) confidence += 0.2;
                
                return Math.min(confidence, 1.0);
            }
            
            calculateStability(values) {
                if (values.length < 2) return 1;
                
                const mean = values.reduce((a, b) => a + b, 0) / values.length;
                const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
                const stdDev = Math.sqrt(variance);
                
                return stdDev / mean;
            }
            
            generateRecommendations(analysis) {
                const recommendations = [];
                
                if (analysis.leakDetection.hasLeak) {
                    recommendations.push({
                        type: 'critical',
                        message: 'æ£€æµ‹åˆ°å†…å­˜æ³„æ¼',
                        details: `æ³„æ¼ç‡: ${analysis.leakDetection.leakRate.toFixed(2)} MB/åˆ†é’Ÿ`,
                        actions: [
                            'æ£€æŸ¥äº‹ä»¶ç›‘å¬å™¨æ˜¯å¦æ­£ç¡®ç§»é™¤',
                            'æ£€æŸ¥å®šæ—¶å™¨æ˜¯å¦æ­£ç¡®æ¸…ç†',
                            'æ£€æŸ¥é—­åŒ…å¼•ç”¨æ˜¯å¦å­˜åœ¨å¾ªç¯å¼•ç”¨',
                            'ä½¿ç”¨æµè§ˆå™¨å¼€å‘å·¥å…·è¿›è¡Œè¯¦ç»†åˆ†æ'
                        ]
                    });
                }
                
                if (analysis.memoryStats.memory.growth > 50 * 1024 * 1024) {
                    recommendations.push({
                        type: 'warning',
                        message: 'å†…å­˜ä½¿ç”¨å¢é•¿è¾ƒå¤§',
                        details: `å¢é•¿: ${(analysis.memoryStats.memory.growth / 1024 / 1024).toFixed(2)} MB`,
                        actions: [
                            'æ£€æŸ¥æ˜¯å¦æœ‰å¤§é‡æ•°æ®ç¼“å­˜',
                            'è€ƒè™‘å®ç°æ•°æ®åˆ†é¡µæˆ–æ¸…ç†æœºåˆ¶',
                            'ä¼˜åŒ–æ•°æ®ç»“æ„å’Œç®—æ³•'
                        ]
                    });
                }
                
                return recommendations;
            }
            
            addListener(listener) {
                this.listeners.push(listener);
            }
            
            removeListener(listener) {
                const index = this.listeners.indexOf(listener);
                if (index > -1) {
                    this.listeners.splice(index, 1);
                }
            }
            
            notifyListeners(event, data) {
                this.listeners.forEach(listener => {
                    try {
                        listener(event, data);
                    } catch (error) {
                        console.error('[MemoryLeakDetector] ç›‘å¬å™¨é”™è¯¯:', error);
                    }
                });
            }
            
            generateReport() {
                const analysis = this.analyzeMemoryUsage();
                
                return {
                    timestamp: new Date().toISOString(),
                    summary: {
                        isMonitoring: this.isMonitoring,
                        duration: analysis.duration,
                        samplesCount: analysis.totalSamples,
                        hasLeak: analysis.leakDetection?.hasLeak || false,
                        leakRate: analysis.leakDetection?.leakRate || 0
                    },
                    details: analysis,
                    samples: this.samples.slice(-50)
                };
            }
            
            cleanup() {
                this.stopMonitoring();
                this.samples = [];
                this.listeners = [];
                console.log('[MemoryLeakDetector] èµ„æºå·²æ¸…ç†');
            }
        }
    </script>
    <script>
        
        class MemoryLeakTestUI {
            constructor() {
                this.detector = new MemoryLeakDetector();
                this.chart = null;
                this.chartData = [];
                this.simulatedLeaks = [];
                
                this.initializeUI();
                this.setupEventListeners();
                this.setupDetectorListeners();
                
                this.log('å†…å­˜æ³„æ¼æ£€æµ‹å·¥å…·å·²åˆå§‹åŒ–', 'info');
            }
            
            initializeUI() {
                // åˆå§‹åŒ–å›¾è¡¨
                this.initChart();
                
                // æ›´æ–°åˆå§‹çŠ¶æ€
                this.updateStats();
            }
            
            setupEventListeners() {
                document.getElementById('startBtn').addEventListener('click', () => {
                    this.startMonitoring();
                });
                
                document.getElementById('stopBtn').addEventListener('click', () => {
                    this.stopMonitoring();
                });
                
                document.getElementById('clearBtn').addEventListener('click', () => {
                    this.clearData();
                });
                
                document.getElementById('reportBtn').addEventListener('click', () => {
                    this.generateReport();
                });
                
                document.getElementById('testLeakBtn').addEventListener('click', () => {
                    this.simulateMemoryLeak();
                });
            }
            
            setupDetectorListeners() {
                this.detector.addListener((event, data) => {
                    switch (event) {
                        case 'monitoring_started':
                            this.log('å¼€å§‹å†…å­˜ç›‘æ§', 'success');
                            this.updateMonitoringStatus(true);
                            break;
                            
                        case 'monitoring_stopped':
                            this.log('åœæ­¢å†…å­˜ç›‘æ§', 'info');
                            this.updateMonitoringStatus(false);
                            this.showAnalysisResults(data);
                            break;
                            
                        case 'sample_collected':
                            this.updateChart(data);
                            this.updateStats(data);
                            break;
                            
                        case 'anomaly_detected':
                            this.handleAnomaly(data);
                            break;
                    }
                });
            }
            
            startMonitoring() {
                this.detector.startMonitoring();
            }
            
            stopMonitoring() {
                this.detector.stopMonitoring();
            }
            
            clearData() {
                this.chartData = [];
                this.updateChart();
                this.updateStats();
                this.hideRecommendations();
                this.log('æ•°æ®å·²æ¸…é™¤', 'info');
            }
            
            generateReport() {
                const report = this.detector.generateReport();
                this.downloadReport(report);
                this.log('æŠ¥å‘Šå·²ç”Ÿæˆå¹¶ä¸‹è½½', 'success');
            }
            
            simulateMemoryLeak() {
                // æ¨¡æ‹Ÿå†…å­˜æ³„æ¼
                const leak = {
                    data: new Array(100000).fill('memory leak simulation'),
                    timer: setInterval(() => {
                        leak.data.push(new Array(1000).fill(Math.random()));
                    }, 100)
                };
                
                this.simulatedLeaks.push(leak);
                this.log('å·²å¯åŠ¨å†…å­˜æ³„æ¼æ¨¡æ‹Ÿ (æ¯100mså¢åŠ 1MB)', 'warning');
                
                // 10ç§’åè‡ªåŠ¨åœæ­¢
                setTimeout(() => {
                    clearInterval(leak.timer);
                    this.log('å†…å­˜æ³„æ¼æ¨¡æ‹Ÿå·²åœæ­¢', 'info');
                }, 10000);
            }
            
            updateMonitoringStatus(isMonitoring) {
                const startBtn = document.getElementById('startBtn');
                const stopBtn = document.getElementById('stopBtn');
                const indicator = startBtn.querySelector('.status-indicator');
                
                if (isMonitoring) {
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                    startBtn.innerHTML = '<span class="status-indicator status-monitoring"></span>ç›‘æ§ä¸­...';
                    indicator.className = 'status-indicator status-monitoring';
                } else {
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                    startBtn.innerHTML = '<span class="status-indicator status-stopped"></span>å¼€å§‹ç›‘æ§';
                    indicator.className = 'status-indicator status-stopped';
                }
            }
            
            updateStats(sample = null) {
                const currentMemoryEl = document.getElementById('currentMemory');
                const memoryGrowthEl = document.getElementById('memoryGrowth');
                const durationEl = document.getElementById('monitoringDuration');
                const leakRiskEl = document.getElementById('leakRisk');
                const domNodesEl = document.getElementById('domNodes');
                const sampleCountEl = document.getElementById('sampleCount');
                
                if (sample) {
                    // æ›´æ–°å½“å‰å†…å­˜
                    const currentMB = (sample.memory.used / 1024 / 1024).toFixed(1);
                    currentMemoryEl.textContent = `${currentMB} MB`;
                    
                    // æ›´æ–°DOMèŠ‚ç‚¹æ•°
                    domNodesEl.textContent = sample.domNodes.toLocaleString();
                    
                    // è®¡ç®—å†…å­˜å¢é•¿
                    if (this.detector.baseline) {
                        const growth = sample.memory.used - this.detector.baseline.used;
                        const growthMB = (growth / 1024 / 1024).toFixed(1);
                        memoryGrowthEl.textContent = `${growthMB} MB`;
                        
                        // æ›´æ–°å¢é•¿çŠ¶æ€
                        const growthCard = memoryGrowthEl.closest('.stat-card');
                        if (growth > 50 * 1024 * 1024) {
                            growthCard.className = 'stat-card danger';
                        } else if (growth > 20 * 1024 * 1024) {
                            growthCard.className = 'stat-card warning';
                        } else {
                            growthCard.className = 'stat-card';
                        }
                    }
                    
                    // æ›´æ–°ç›‘æ§æ—¶é•¿
                    if (this.detector.samples.length > 0) {
                        const duration = (sample.timestamp - this.detector.samples[0].timestamp) / 1000;
                        durationEl.textContent = `${Math.floor(duration)} ç§’`;
                    }
                    
                    // æ›´æ–°æ ·æœ¬æ•°é‡
                    sampleCountEl.textContent = this.detector.samples.length.toLocaleString();
                    
                    // è¯„ä¼°æ³„æ¼é£é™©
                    this.updateLeakRisk(leakRiskEl);
                } else {
                    // é‡ç½®æ˜¾ç¤º
                    currentMemoryEl.textContent = '0 MB';
                    memoryGrowthEl.textContent = '0 MB';
                    durationEl.textContent = '0 ç§’';
                    leakRiskEl.textContent = 'ä½';
                    domNodesEl.textContent = '0';
                    sampleCountEl.textContent = '0';
                }
            }
            
            updateLeakRisk(element) {
                if (this.detector.samples.length < 10) {
                    element.textContent = 'è¯„ä¼°ä¸­';
                    element.closest('.stat-card').className = 'stat-card';
                    return;
                }
                
                const analysis = this.detector.analyzeMemoryUsage();
                const leakDetection = analysis.leakDetection;
                
                if (leakDetection.hasLeak) {
                    if (leakDetection.confidence > 0.7) {
                        element.textContent = 'é«˜';
                        element.closest('.stat-card').className = 'stat-card danger';
                    } else {
                        element.textContent = 'ä¸­';
                        element.closest('.stat-card').className = 'stat-card warning';
                    }
                } else {
                    element.textContent = 'ä½';
                    element.closest('.stat-card').className = 'stat-card';
                }
            }
            
            initChart() {
                const canvas = document.getElementById('memoryChart');
                const ctx = canvas.getContext('2d');
                
                // è®¾ç½®canvaså°ºå¯¸
                canvas.width = canvas.offsetWidth * window.devicePixelRatio;
                canvas.height = canvas.offsetHeight * window.devicePixelRatio;
                ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                
                this.chart = { canvas, ctx };
                this.drawChart();
            }
            
            updateChart(sample = null) {
                if (sample) {
                    this.chartData.push({
                        timestamp: sample.timestamp,
                        memory: sample.memory.used,
                        domNodes: sample.domNodes
                    });
                    
                    // ä¿æŒæœ€å¤š300ä¸ªæ•°æ®ç‚¹
                    if (this.chartData.length > 300) {
                        this.chartData.shift();
                    }
                }
                
                this.drawChart();
            }
            
            drawChart() {
                if (!this.chart) return;
                
                const { ctx, canvas } = this.chart;
                const width = canvas.offsetWidth;
                const height = canvas.offsetHeight;
                
                // æ¸…ç©ºç”»å¸ƒ
                ctx.clearRect(0, 0, width, height);
                
                if (this.chartData.length === 0) {
                    // æ˜¾ç¤ºç©ºçŠ¶æ€
                    ctx.fillStyle = '#999';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('æš‚æ— æ•°æ®', width / 2, height / 2);
                    return;
                }
                
                // è®¡ç®—æ•°æ®èŒƒå›´
                const memoryValues = this.chartData.map(d => d.memory);
                const minMemory = Math.min(...memoryValues);
                const maxMemory = Math.max(...memoryValues);
                const memoryRange = maxMemory - minMemory || 1;
                
                // ç»˜åˆ¶ç½‘æ ¼
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 1;
                
                // å‚ç›´ç½‘æ ¼çº¿
                for (let i = 0; i <= 10; i++) {
                    const x = (width / 10) * i;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                }
                
                // æ°´å¹³ç½‘æ ¼çº¿
                for (let i = 0; i <= 5; i++) {
                    const y = (height / 5) * i;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
                
                // ç»˜åˆ¶å†…å­˜ä½¿ç”¨æ›²çº¿
                if (this.chartData.length > 1) {
                    ctx.strokeStyle = '#4CAF50';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    this.chartData.forEach((point, index) => {
                        const x = (index / (this.chartData.length - 1)) * width;
                        const y = height - ((point.memory - minMemory) / memoryRange) * height;
                        
                        if (index === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    
                    ctx.stroke();
                }
                
                // ç»˜åˆ¶Yè½´æ ‡ç­¾
                ctx.fillStyle = '#666';
                ctx.font = '12px Arial';
                ctx.textAlign = 'right';
                
                for (let i = 0; i <= 5; i++) {
                    const value = minMemory + (memoryRange / 5) * (5 - i);
                    const y = (height / 5) * i + 5;
                    ctx.fillText(`${(value / 1024 / 1024).toFixed(1)}MB`, width - 5, y);
                }
            }
            
            handleAnomaly(data) {
                switch (data.type) {
                    case 'rapid_growth':
                        this.log(`âš ï¸ æ£€æµ‹åˆ°å†…å­˜å¿«é€Ÿå¢é•¿: ${(data.growth / 1024 / 1024).toFixed(1)}MB`, 'warning');
                        break;
                        
                    case 'high_usage':
                        this.log(`ğŸš¨ å†…å­˜ä½¿ç”¨è¿‡é«˜: ${(data.usage / 1024 / 1024).toFixed(1)}MB`, 'error');
                        break;
                }
            }
            
            showAnalysisResults(analysis) {
                const container = document.getElementById('recommendationsContainer');
                const list = document.getElementById('recommendationsList');
                
                if (!analysis.recommendations || analysis.recommendations.length === 0) {
                    container.style.display = 'none';
                    return;
                }
                
                list.innerHTML = '';
                
                analysis.recommendations.forEach(rec => {
                    const div = document.createElement('div');
                    div.className = `recommendation ${rec.type}`;
                    
                    div.innerHTML = `
                        <div class="recommendation-title">${rec.message}</div>
                        <div>${rec.details}</div>
                        <div class="recommendation-actions">
                            <strong>å»ºè®®æ“ä½œ:</strong>
                            <ul>
                                ${rec.actions.map(action => `<li>${action}</li>`).join('')}
                            </ul>
                        </div>
                    `;
                    
                    list.appendChild(div);
                });
                
                container.style.display = 'block';
            }
            
            hideRecommendations() {
                document.getElementById('recommendationsContainer').style.display = 'none';
            }
            
            downloadReport(report) {
                const blob = new Blob([JSON.stringify(report, null, 2)], {
                    type: 'application/json'
                });
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `memory-leak-report-${new Date().toISOString().slice(0, 19)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            log(message, type = 'info') {
                const container = document.getElementById('logContainer');
                const entry = document.createElement('div');
                entry.className = `log-entry log-${type}`;
                
                const timestamp = new Date().toLocaleTimeString();
                entry.textContent = `[${timestamp}] ${message}`;
                
                container.appendChild(entry);
                container.scrollTop = container.scrollHeight;
                
                // ä¿æŒæœ€å¤š100æ¡æ—¥å¿—
                while (container.children.length > 100) {
                    container.removeChild(container.firstChild);
                }
            }
        }
        
        // åˆå§‹åŒ–åº”ç”¨
        window.addEventListener('DOMContentLoaded', () => {
            try {
                new MemoryLeakTestUI();
            } catch (error) {
                console.error('åˆå§‹åŒ–å¤±è´¥:', error);
                document.getElementById('logContainer').innerHTML += `
                    <div class="log-entry log-error">
                        [ERROR] åˆå§‹åŒ–å¤±è´¥: ${error.message}
                    </div>
                `;
            }
        });
    </script>
</body>
</html>
